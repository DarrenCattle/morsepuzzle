//Darren Cattle
//February 2016
//lib.js
//Function Library

function functionalLoop(base, remove, limb) {
  //Calculate possible removals with a 2D Array (Matrix)
  var intersect = createMatrix(base, remove);
  //Calculate all possible outcomes using matrix and base string
  var solveList = solveFunctionally(intersect, base);

  //JavaScript does not have overloading so manually check for limb
  if(limb == null) {
    return solveList;
  }
  else {
    //If limb exists, use 1st removal outcomes to calculate 2nd removal outcomes
    return checkLimb(solveList, limb);
  }
};

function createMatrix(base, remove) {

  var intersect = [];

  //Create intersection matrix between base and remove
  for (var a = 0; a < remove.length; a++) {
    intersect[a] = [a];
    for (var b = 0; b < base.length; b++) {
      if (remove.charAt(a) === base.charAt(b)) {
        if (a > b) {
          intersect[a][b] = '';
          continue;
        }
        intersect[a][b] = remove.charAt(a);
        continue;
      }
      intersect[a][b] = '';
    }
  }

  //Final step for staggered diagonalization
  for (var a = 0; a < remove.length-1; a++) {
    for (var b = 0; b < base.length; b++) {
      if (intersect[a][b]!='') {
        intersect[a+1][b]='';
        break;
      }
      intersect[a][b]='';
    }
  }

  return intersect;
};

function solveFunctionally(intersect, base) {

  //setup variables, height and width are stored in intersect naturally
  var answerList = {};
  var width = intersect[0].length;
  var height = intersect.length;
  //look through the whole matrix starting at 0,0 and find all possible paths
  var paths = lookBelow(0,0,base);

  function xChar(str, index) {
    if(index === 0) {
      return 'X' + str.substring(1, str.length);
    }
    if(index === str.length-1) {
      return str.substring(0, str.length-1) + 'X';
    }
    return str.substring(0,index) + 'X' + str.substring(index+1,str.length);
  };

  function count(str, symbol) {
    var total = 0;
    for(var a = 0; a < str.length; a++) {
      if(str.charAt(a)===symbol) {
        total++;
      }
    }
    return total;
  };

  function lookBelow(startX, startY, path) {
    //Iterate along x until we find a valid char calculated by intersect
    for (var x = startX; x < width; x++) {

      if (intersect[startY][x] !== '') {
        //Replace characters we will remove with X to keep indices the same
        nextPath = xChar(path, x);
        //If we have removed the full removal string, add to answers and finish
        if(count(nextPath,'X') === height) {
          //using a Javascript Object Map so that identical results are not stored
          answerList[nextPath.replace(/X/g,'')]=true;
          continue;
        }
        //Make sure that we are within x bound. Break because x is finite.
        var nextX = x + 1;
        if (nextX > width) {
          break;
        }
        //Make sure that we are within y bounds. Continue because we iterate along x.
        var nextY = startY + 1;
        if (nextY > height - 1) {
          continue;
        }
        //If next coordinates are valid, look below at those coordinates
        lookBelow(nextX, nextY, nextPath);
      }
    }
  };

  return answerList;

};

function checkLimb(solveList, limb) {

  var finalList = {};
  //iterate over solveList
  Object.keys(solveList).forEach(function calculateLimb(base) {
    
    var intersect = createMatrix(base, limb);

    var secondList = solveFunctionally(intersect, base);

    if (!secondList) {
      return;
    }
    //iterate over secondList generated by solveList for finalList of answers
    Object.keys(secondList).forEach(function addPaths(path) {
      //using a Javascript Object Map so that identical results are not stored
      finalList[path] = true;
    });

  });

  return finalList;

};

module.exports = {
  functionalLoop: functionalLoop,
};